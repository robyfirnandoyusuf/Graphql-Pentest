## Auth

### 1. Authentication
Authentication is determining whether a given user is logged in and subsequently remembering who they are. Authentication can provide context to a session and personalize the type of data that a user sees.

### 2. Authorization
Authorization is then determining what a given user has permission to do or see. In GraphQL, we’d use this to manage access to particular queries and mutations based on identity, role, or permissions.

### 3. Mitigate malicious queries
Limit query depth

GraphQL gives clients the ability to ask for data in a variety of different ways. Because of the various entry-points available to request data, it’s possible to write exceptionally large nested queries like the following.
```
query {
  author(id: 42) {
    posts {
      author {
        posts {
          author {
            posts {
              author {
                # and so on...
              }
            }
          }
        }
      }
    }
  }
}
```
I recommend using a library like [graphql-depth-limit](https://github.com/stems/graphql-depth-limit) to specify the max depth across your queries to mitigate this problem.

#### Improve validation and sanitization

Validation and sanitization are standard web application security practices. When you accept data from a user, one should always expect that user-provided data could be malicious.

There are two especially malicious techniques in this area: data exfiltration and data destruction.

Data exfiltration is when a client writes a malicious query containing SQL or NoSQL code that tricks the database into returning more data than originally intended. For example, the following un-sanitized query could trick a SQL-based data source into returning all of the fields for a user, including their email and hashed password.

Use timeouts

When we request data from downstream services or data sources, there are various reasons why it may take a long time to respond. The services may be down, queries may be expensive, or something else might be going on. Regardless of the reason, we don’t want our GraphQL API to hang for too long, waiting for a response.

To prevent this, I recommend using timeouts to keep from slow or unresponsive services impacting performance for subsequent queries.

#### Rate limit APIs

Rate limiting is when you dictate how many requests a client can make per some time. Often, we use rate-limiting to prevent brute-forcing login details, scraping data, or denial of service attacks.

### 4. Limit API discoverability
This next section is about security by obscurity — a way to reduce the attack surface by making it harder for malicious parties to discover API capabilities.

#### Turn off introspection in production

Introspection is a technique to provide detailed information about a GraphQL API’s schema.

While introspection is primarily helpful for diagnostic and GraphQL tooling in development, we recommend turning it off in production. Doing so prevents accidentally sharing business secrets and vastly reduces the ability of a malicious actor to discover how to abuse a GraphQL API.

For a more in-depth discussion and to learn how to turn introspection off in production, read “Why You Should Disable GraphQL Introspection In Production – GraphQL Security“.

#### Mask errors

When server or downstream service errors occur, it’s a good idea to withhold the exact specifics of what went wrong from the client.

Informing the client about error details in the server exposes the current server vulnerabilities and opens the door for more concentrated attacks.

For example, the following error reveals information about the source code and even, potentially, the type of databases we may be using.

```
"data": {
	 "astronaut": null
 },
 "errors": [
	 {
		 "message": "Database Error: Astronaut does not exist",
		 "extensions": {
		 "code": "INTERNAL_SERVER_ERROR",
		 // ...
		 "exception": {
		 "stacktrace": [
			 "Database Error: User does not exist",
				 " at __resolveReference (../services/vehicles/index.js:29:13)”,
				 // ...
				],
				// …
			 }
			}
		}
	]
}
```

Special thanks to the brilliant Mandi Wise for her experience securing GraphQL APIs.
